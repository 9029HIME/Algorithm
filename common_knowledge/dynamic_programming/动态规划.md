# 斐波那契数列-提出DP

以下是一个经典的斐波那契数列代码，求的是第i个斐波那契数的值：

```go
package main

import "fmt"


func main() {
   fmt.Println(fn(25))
}

func fn(i int) int{
   if i==1 || i==2{
      return 1
   }
   result := fn(i-1) + fn(i-2)
   return result
}
```

采用了递归的方式，出口是i=1或i=2，递归的顺序是先递归i-1，再递归i-2。如果画出流程图的话，fn(6)的处理流程是这样的（**节选**）：

![DP前](https://user-images.githubusercontent.com/48977889/169237593-3b3ebd83-d081-4e3e-a5c8-f221a8343db5.jpg)

如果使用暴力的递归，总共经历了14次调用。可以看到在fn(6)的过程中，fn(4)其实被调用了2次，fn(4)被调用了2次导致fn(3)、fn(2)、fn(1)被调用了许多次。实际上第1+n次重复的调用都是无意义的，随着fn(i)里i的数量递增，无意义的调用次数呈指数增长，不仅降低了程序运行效率，还有可能引发栈空间危机。

实际上，即使是重复调用，重复函数之间也是按顺序执行的，在fn(i)往左派生的时候实际会把fn(i)到fn(1)的结果都算一遍了。也就是说在函数第1次被调用完之后将结果存入一个集合里，当第1+n次调用时先判断集合内是否存在结果，如果存在直接返回，**这样函数的派生函数就不会被重复执行，效率显著提高**，落实到代码如下：

```go
package main

import (
   "fmt"
   "time"
)
var FI_RESULT map[Integer]Integer = make(map[Integer]Integer,10)

type Integer int

func main() {
   now := time.Now()
   fmt.Println(fn(45))
   since := time.Since(now)
   fmt.Println(since.Seconds())
}

func fn(i Integer) Integer{
   if i==1 || i==2{
      return 1
   }
   tempResult := FI_RESULT[i]
   if tempResult != 0{
      return tempResult
   }
   result := fn(i-1) + fn(i-2)
   FI_RESULT[i] = result
   return result
}
```

此时它的执行流程就是：

![DP后](https://user-images.githubusercontent.com/48977889/169237752-fd5b96e0-c3dd-44ec-a14c-b915cc54d254.jpg)

直接从14次调用变成8次调用，这就是动态规划：**将重复求解的子问题（或派生函数）的结果（或最优解）保存起来，等待下一次直接使用，达到记忆化搜索与剪枝（配合上面2张图看）的作用。**

# JOB规划问题-使用DP

![51eee81603f98c3017ab0951fe5eb1a](https://user-images.githubusercontent.com/48977889/169240077-e9245e84-1e96-422b-9afc-a7c2d187c4ac.jpg)

有这么一个问题：横坐标是时间0到11点，上面的灰色方块指的是工作JOB，JOB的长度指的是占用时间的大小，JOB的红色数字指的是完成后的酬劳，在纵轴上有交集的JOB无法共同选择，那我作为一个工人，如何在0-11点这个时间范围内选择最合适的JOB搭配呢？

我们现把问题拆分一下，假设现在工人只有0-5点，在这个时间段内，只能选择JOB1和JOB2，对于工人来说，按照时间先后顺序，只能这样选择：

![image](https://user-images.githubusercontent.com/48977889/169254076-2456678e-021d-4487-a764-a66eda9cc7ba.png)

对于工人来说，JOB1选择的最高收益是5，不选的最高收益是1。肯定是选择JOB1的收益高。

那再扩展一点，工人在0-6这个时间段呢：

![image](https://user-images.githubusercontent.com/48977889/169254096-20b79649-a6a2-4124-bdee-2a413887cd0f.png)

对于工人来说，这个时间段内选择JOB3收益才是最高的。

我再扩大点范围，现在是0-7点：

![image](https://user-images.githubusercontent.com/48977889/169254150-2eff40de-9ac2-4de0-81d8-1f59b7f4efa4.png)

此时选择JOB1+JOB4才是收益最高的。从这里就能看到重复子问题JOB4了。对于JOB选择问题，其实可以划分以下步骤：

1. 这个Job是选择还是不选？**选的收益和不选的收益是多少?**
2. 选，如果我选了它，Job的收益就得到了，那下一个能选什么？**下一个选择的收益和不选的收益是多少？**
3. 不选，如果我不选它，那我按照时间排序下一个能选的是什么，**下一个选择的收益和不选的收益是多少？**

可以看到2.和3.作为子问题无论如何走，最终还是会作为问题1继续派生下去。当然，这个问题也是有出口的：**当没有下一个选择项的时候，子问题的值=0**。

如果换成伪代码的话，会更好理解：

1. 定义函数should(i)，它的作用是**返回选择Jobi后，按照时间排序下一个能选择的Job是什么****。
2. 定义函数next(i)，它的作用是**返回不选择Jobi后，按照时间排序下一个能选择的Job是什么**。
3. 定义函数value(i)，它的作用是**返回对于Jobi在选或不选下的最大收益**。
4. 定义函数amount(i)，它的作用是**返回Jobi本身的收益**。

```
value(i) = Max(

​					amount(i) + value(should(i))

​					,value(next(i))

​			)

```

其中Max的左项是选择Jobi的最大收益，右项是不选Jobi的最大收益。不管是左项还是右项都涉及value的递归调用，这时候就很适合使用动态规划来解决：

```GO
package main

// TODO 我只算出了最多赚多少钱，但还没算Job的搭配

// 从早到晚排序的job
var sortedJob []int = []int{3, 1, 2, 5, 4, 6, 7, 8}

// 任务最大数量
var length int = 8
var job2Index map[int]int = map[int]int{
   3: 0,
   1: 1,
   2: 2,
   5: 3,
   4: 4,
   6: 5,
   7: 6,
   8: 7,
}
// 组合搭配
var choice string = ""
// 最优解集合
var job2Result map[int]int = make(map[int]int)
func main() {
   print(value(sortedJob[0]))
}

// 其实应该用更好的方式（根据job的时间占用来排除），不过为了方便，这里直接用代码写死
func should(jobId int) int {
   nextId := -1
   switch jobId {
   case 3:
      nextId = 7
   case 1:
      nextId = 4
   case 2:
      nextId = 6
   case 5:
      nextId = 8
   case 4:
      nextId = 8
   case 6:
      nextId = -1
   case 7:
      nextId = -1
   case 8:
      nextId = -1
   }
   return nextId
}

// 一样，为了方便直接代码写死，并且金额为整型
func amount(jobId int) int {
   reward := 0
   switch jobId {
   case 3:
      reward = 8
   case 1:
      reward = 5
   case 2:
      reward = 1
   case 5:
      reward = 6
   case 4:
      reward = 4
   case 6:
      reward = 3
   case 7:
      reward = 2
   case 8:
      reward = 4
   }
   return reward
}

func next(jobId int) int {
   nextId := -1
   if index, ok := job2Index[jobId]; ok && (index+1) < 8 {
      nextId = sortedJob[index+1]
   }
   return nextId
}

func value(jobId int) int {
   // 出口
   if jobId == -1 {
      return 0
   }
   // 动态规划关键点1，是否已有最优解？
   dpResult,exist:= job2Result[jobId]
   if exist{
      return dpResult
   }
   // 派生子问题
   result := Max(amount(jobId)+value(should(jobId)), value(next(jobId)))
   // 动态规划关键点2，存入最优解
   job2Result[jobId] = result
   return result
}

func Max(a int, b int) int {
   if a >= b {
      return a
   } else {
      return b
   }
}
```

# 上楼梯问题

