# 二叉堆

我给它下一个定义：二叉堆本质是一个基于数组的完全二叉树。

它在逻辑上是一颗完全二叉树，以ABCDEFG这块二叉堆为例，它的树结构是：

![image](https://user-images.githubusercontent.com/48977889/196859105-f53f2369-0cec-4a12-921f-c0cb8fc7194f.png)

但落实到实际的存储，却是一个数组，数组结构是：

![image](https://user-images.githubusercontent.com/48977889/196859145-d76fda2f-8b88-42de-b53c-001b4adeeb66.png)

一般二叉堆都会冗余index=0的下标，作为哑下标，目的是方便计算出index=i的节点，它的左孩子节点下标与右孩子节点下标：

```go
func leftSon(i int) int{
    return i * 2
}

func rightSon(i int) int{
    return (i * 2) + 1
}
```

同样的，也可以算出index=i的节点，他的父节点的下标，当它的父节点下标=0时，代表是堆顶节点：

```go
func father(i int) int{
   return i/2
}
```

# 最大堆与最小堆

它们两个是二叉堆的概念延伸，在二叉堆的基础上，最大堆和最小堆保证了有序性：

最大堆：任意一个节点，它的值都≥它的两个子节点值

最小堆：任意一个节点，它的值都≤它的两个子节点值

**值得注意的是，最大最小堆的有序性 和 红黑树是不一样的，红黑树是中序遍历的结果必定是严格有序，但最大最小堆更关注父节点和子节点的有序性。**

左边是最大堆、右边是红黑树：

![image](https://user-images.githubusercontent.com/48977889/196859196-91744b80-cf4a-44c9-b40d-4f6e5283495d.png)

# 优先级队列

优先级队列是基于最大堆、最小堆概念的延伸。它的核心功能是：往优先级队列插入数据、删除数据后，能够动态维护其有序性。

什么意思呢？假设优先级队列A基于最大堆，往队列A插入数据的时候，默认会插入到数组尾部，然后根据父节点的大小，动态rise到合适节点上，【合适节点】与【rise节点】进行位置替换。

假设A队列的数据如下，我要新增节点8：

![image](https://user-images.githubusercontent.com/48977889/196859451-b546d1fb-36a8-4e06-ab1a-d63e4662eb77.png)

![image](https://user-images.githubusercontent.com/48977889/196859486-1a32a098-9a86-44b3-835d-113cef37f68b.png)

![image](https://user-images.githubusercontent.com/48977889/196859509-edb42c86-fc06-4fb8-9b6e-fb261a4b4a57.png)

如果往队列A删除数据呢？【被删除节点】需要和【最后节点】进行替换，然后删除【被删除节点】。此时【最后节点】被挪到了高位，很明显违背了最大堆的特性，需要动态sink到合适的节点上。

假设A队列的数据如下，我要删除节点7：

![image](https://user-images.githubusercontent.com/48977889/196859631-b1833398-75fb-45c0-8dbc-76abfe7ea4af.png)

![image](https://user-images.githubusercontent.com/48977889/196859651-90b3b6a7-0a34-4d20-aee0-e7d4d742b02b.png)

![image](https://user-images.githubusercontent.com/48977889/196859678-1314f48e-c473-4f7f-a727-11012ec0d5d9.png)