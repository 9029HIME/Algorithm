# 前置内容

交易 = 1次买入 + 1次卖出。交易的前提是买入，即使买入后不卖出也行。

经典的**求选择带来的最大值**问题，和[最小消耗爬楼梯](https://github.com/9029HIME/Algorithm/tree/master/leetCode/20221124_EASY_746_Min_Cost_Climbing_Stairs---DP)是同一种题型。但股票问题本身的分析难度比较大，推导状态转移方程的过程比较复杂，所以有必要专门出一套合集来分析这个问题。

# 思路

## 状态转移方程的推导

股票问题的DP数组比较特殊，它是一个三维数组dp[i]\[k\]\[1/0\]。其中：

```
i = 第i天
k = 最大交易限制数k
1/0 = 1代表持有股票，0代表不持有股票
```

即

```
dp[i][k][1] = 我在第i天，最大交易限制数为k的前提下，持有股票的最高收益。
dp[i][k][0] = 我在第i天，最大交易限制数为k的前提下，不持有股票的最高收益。
```

也就是说，对dp[ i ]\[ k \]\[ 0 \]和dp[ i ]\[ k \]\[ 1 ]取最大值，即是题目想要的答案。那么状态转移方程该如何推导呢？

先看dp[ i ]\[ k \]\[ 0 \]，假设我第i天没持有股票，无非就2种情况：

1. 我昨天没持有股票，今天有没持有。 对应的最大收益是 昨天没持有股票的最大收益 ，即 dp[ i-1 ]\[ k \]\[ 0 \]。
2. 我昨天持有股票，今天卖出了。 对应的最大收益是 多天持有股票的最大收益 + 今天卖出的价值， 即dp[ i-1 ]\[ k \][ 1 ] + prices[i]。

需要对2种情况取最大值，即是dp[i]\[k\]\[0\]的收益最大值，即

```
dp[i][k][0] = MAX( dp[i-1][k][0] , dp[i-1][k][1] + prices[i] )
```

同理，假设我第i天持有股票，也无非就2种情况：

1. 我昨天没持有股票，今天买入了。 对应的最大收益是 昨天没持有股票的最大收益 - 今天买入股票的钱，即  dp[ i-1 ]\[ k-1 \]\[ 0 \] - price[i]。
2. 我昨天持有股票，今天继续持有。 对应的最大收益是 昨天持有股票的最大收益。 即dp[ i-1 ]\[ k \]\[ 1 \]。

需要对2种情况取最大值，即是dp[i]\[k\]\[1\]收益的最大值，即

```
dp[i][k][1] = MAX( dp[i-1][k-1][0] - prices[i]  ,  dp[i-1][k][1])
```

**慢着！！！为什么昨天没持有股票的最大收益要k-1？这其实是这道题状态转移方程推导的最大难点！！！**

因为k是当天最大交易次数限制。我今天在k的情况下决定持有，那我昨天必须在 **k-1的情况下没有持有，然后今天买入** 或者 **在k的情况下持有，今天继续持有。**

为了防止以后我再看这篇思路，还是没理解，以k = 2, prices = [3,2,6,5,0,3]为例：

![image-20221210174435924](markdown-img/股票问题-思路总结.assets/image-20221210174435924.png)

假设i=5，我在第5天没持有股票，准备买，如果我的最大限制数还是2的话

![image-20221210174450857](markdown-img/股票问题-思路总结.assets/image-20221210174450857.png)

进行购入以后，我在第6天想继续持有，那我的k值只能是1，即dp[6]\[1\]\[1\]，但我的本意想求dp[6]\[2\]\[1\]，所以不满足：

![image-20221210174554226](markdown-img/股票问题-思路总结.assets/image-20221210174554226.png)

**为了预留一次今日买入的机会，所以前一天的最大限制数必须-1。**

## dp出口的推导

