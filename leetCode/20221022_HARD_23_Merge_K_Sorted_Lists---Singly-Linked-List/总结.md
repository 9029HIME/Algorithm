# 题目

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

# 示例

输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6



输入：lists = []
输出：[]



输入：lists = [[]]
输出：[]

# 思路

## 简单入手：合并两个有序链表

其实这和leetcode21题：合并两个有序链表很相似，只不过21题是本题K=2的场景。不妨来回顾一下合并两个有序链表是怎么做的，假设有1链表和2链表：

![image](https://user-images.githubusercontent.com/48977889/197316352-2826e3c6-d1a0-423b-bd55-6bcb7374d8db.png)

有个条件非常重要：这两个链表本身就是有序的，因此先从两个链表按顺序各拿一个节点，比较它们的大小：

![image](https://user-images.githubusercontent.com/48977889/197316414-16974e2d-d109-4ab6-92d2-f383d5528d33.png)

那我假设A1＜A2，此时A1是比较小的节点，将它放进Result链表里，注意Result链表本身也是单链表，**为了保证尾插发的效率，需要维护一个Tail节点**。

此时2链表的R指针不用发生挪动，因为它仍是1链表与2链表之间最大的，1链表A1已经被挪出去了，所以L指针往右移动，继续和A2进行比较：

![image](https://user-images.githubusercontent.com/48977889/197316501-913ed181-f6f5-4fee-b122-72622e24b12f.png)

假设B1还是＜A2，就将B1添加到Result链表里，继续挪动Tail和L指针的位置，进行下一次比较：

![image](https://user-images.githubusercontent.com/48977889/197316620-f062bdd9-73f3-4352-9fa9-80a1f05f95fb.png)

现在局面发生了好转，C1是＞A2的，A2就要被挪到Result队列，这次轮到L指针不变，需要挪动Tail指针和R指针的位置。

那我现在假设C1和D1都＜B2：

![image](https://user-images.githubusercontent.com/48977889/197316697-63ab1ffe-3fdd-446f-9044-4fed8fcab0b5.png)

和上面一样，C1和D1都被挪到Result链表里，R指针仍不变，Tail指针指向D1，而L指针因为1链表的遍历完成，顺理成章指向nil。当其中链表被遍历完毕，**直接将另一个链表追加到Result链表上，至此链表合并完成**：

![image](https://user-images.githubusercontent.com/48977889/197316785-7b055334-38db-465d-9c8d-131f9ddd8ed9.png)

此时R指针仍是指向B2，总的来说就是：

1. L和R比较哪个更大，【比较值小的指针】指向的节点被挪到Result链表（注意维护Tail指针）。
2. 【比较值小的指针】往右挪，【比较值大的指针】保持不变。
3. 当发现其中一个指针指向nil了，说明这个链表已经被遍历完，直接将【另一个指针】指向的链表追加到Result链表。
4. Result链表既是结果。

## 合并两个有序链表代码

### 节点与链表

先定义好节点和链表，等下在合并K个有序链表时复用：

```go
package main

import "fmt"

/**
链表与节点的定义
*/
type Node struct {
   next *Node
   val  int
}

type SinglyLinkedList struct {
   head *Node
}

/**
初始化有序链表（切片得是有序的）
*/
func InitSinglyLinkedList(values []int) *SinglyLinkedList {
   list := new(SinglyLinkedList)
   list.head = new(Node)

   node := list.head
   for _, v := range values {
      n := new(Node)
      n.val = v
      node.next = n
      node = node.next
   }

   return list
}

/**
获取Result链表
*/
func NewSinglyLinkedList() *SinglyLinkedList {
   list := new(SinglyLinkedList)
   list.head = new(Node)
   return list
}

/**
打印链表结构
*/
func (this *SinglyLinkedList) introduce() {
   result := "head-->"
   node := this.head.next
   for node != nil {
      val := fmt.Sprintf("%v-->", node.val)
      result = result + val
      node = node.next
   }
   result = result[0 : len(result)-3]
   fmt.Println(result)
   fmt.Println()

}
```

### 实际的合并代码

```go
package main

/**
合并两个有序链表的方法
*/
func Merge2SortedLists(l1 *SinglyLinkedList, l2 *SinglyLinkedList) *SinglyLinkedList {
   result := NewSinglyLinkedList()
   tail := result.head

   l := l1.head.next
   r := l2.head.next

   for l != nil && r != nil {
      lVal := l.val
      rVal := r.val
      var minNode *Node

      // 毕竟是单链表，出队操作比较复杂，逻辑出队就好了
      if lVal <= rVal {
         minNode = l
         l = l.next
      } else {
         minNode = r
         r = r.next
      }

      rN := new(Node)
      rN.val = minNode.val
      // 维护tail
      tail.next = rN
      tail = tail.next
   }

   // 走到这 说明已经有一个队列遍历完毕了
   if l == nil {
      tail.next = r
   } else {
      tail.next = l
   }

   return result
}
```

### 单元测试用例

```go
func Test2Lists(t *testing.T) {
   values1 := []int{1, 3}
   values2 := []int{2, 4, 6, 8}

   l1 := InitSinglyLinkedList(values1)
   l2 := InitSinglyLinkedList(values2)

   result := Merge2SortedLists(l1, l2)
   result.introduce()
}
```

## 开始变难；如果是合并K个呢？
