package main

import "math"

/**
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

===============================================================================================================

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

===============================================================================================================
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
*/

/**
我的思路1：
1.之前买的股票，之后才能卖出，也就是说只有在后面的日子才能知道利益是多少，也就是说这道题需要倒序考虑。
2.核心目的：算出每1天的最大利益，选择范围内每1天的最大利益，就是题目的解。
3.那我怎么才能知道这1天的最大利益呢？那就得找到这1天之前股价最小值是什么，而且必须存在小于或等于这1天的股价的最小值，否则这1天的价值为0
4.这么一看，只需从尾到头排序，再从当天到第1天倒序排序即可，时间复杂度是O(n(n-m))。n是总天数，m是当前天数的前面天数


我的思路2：
1.这道题好像有1个很明显的突破口：右边的最大值 - 左边的最小值就是解
2.从左到右遍历，看这个数是否小于已知最小值？是的话，它就是已知最小值，不是的话就让它减去已知最小值，算出临时利润。
3.在遍历的过程中，会不断地产生临时利润，新临时利润需要比较旧临时利润，选出最大值
4.这个思路有一个非常巧妙的点：它的最小值和最大值是不断变化的，比如[3,10,1,15]这个组合，当遍历到10的时候，最小值是3，最大利润是7。一旦遍历到1的时候发现1
	比临时最小值3还小，此时最小值易位为1，1之前的股价哪怕是9999999999也和1没任何关系了，只需关注之后的利润是否比旧利润高就好。

吐槽点：我看leetcode上这题被划分成“动态规划”分类，可是我左看右看，硬要套上动态规划的话最终只能是单纯的递归调用。因为子任务之间好像没有重复依赖，剪不了枝，不需要记忆化搜索。
*/

var prices []int = []int{7, 6, 4, 3, 1}

func main() {
	print(maxProfit(prices))
}

func maxProfit(prices []int) int {
	minValue := math.MaxInt64
	max := 0
	for _, v := range prices {
		if v <= minValue {
			minValue = v
		} else {
			tempProfit := v - minValue
			if tempProfit > max {
				max = tempProfit
			}
		}
	}
	return max
}
